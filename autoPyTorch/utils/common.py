import hashlib
from typing import Any, Dict, Iterable, Iterator, List, NamedTuple, Optional, Type, Union

import numpy as np

import pandas as pd

import scipy.sparse

import torch
from torch.utils.data.dataloader import default_collate


_prohibited = ['items', 'keys', 'pkg_check', 'values']


class BaseNamedTuple():
    """
    A class that extends the NamedTuple package.
    This class allows NamedTuple to be used like a dict
    by inheriting this class.
    Therefore, self must be NamedTuple class.

    Examples:
        >>> class menu(NamedTuple):
        >>>     fish: int = 5
        >>>     meat: int = 10
        >>>     drink: int = 7

        >>> today = create_dictlike_namedtuple(menu, fish=3, meat=13)
        >>> for key, value in today.items():
        >>>     print(key, value)
            fish 3
            meat 13
            drink 7

        >>> print(today)
            BaseNamedTuple('menu', {'fish': 3, 'meat': 13, 'drink': 7})

        >>> print(today["meat"], today.fish)
            13 3

        >>> today["fish"] = 10
            TypeError: 'WrapedNamedTuple' object does not support item assignment

    Note:
        When you inherit NamedTuple class,
        you cannot inherit any other class at the same time.
        For this reason, we have to use `create_dictlike_namedtuple`.

    """

    def pkg_check(self) -> bool:
        if hasattr(self, "_asdict"):
            return True
        else:
            raise AttributeError("The child class of BaseNamedTuple must inherit NamedTuple class.")

    def keys(self) -> Iterator:
        self.pkg_check()
        return getattr(self, '_asdict')().keys()

    def values(self) -> Iterator:
        self.pkg_check()
        return getattr(self, '_asdict')().values()

    def items(self) -> Iterator:
        self.pkg_check()
        return getattr(self, '_asdict')().items()


def create_dictlike_namedtuple(target_namedtuple: Any, **kwargs: Any) -> Any:
    """Returns a dict-like immutable NamedTuple

    The function that returns the NamedTuple
    that inherits the BaseNamedTuple.
    Since class that inherits NamedTuple cannot
    inherit any other class at the same time,
    This function wraps the procedure to inherit
    BaseNamedTuple class.

    Args:
        target_namedtuple (Any): A class that inherits NamedTuple
        kwargs (Any): The contents of the given NamedTuple.

    Returns:
        (WarpedNamedTuple): A dict-like immutable NamedTuple

    Examples:
        >>> class menu(NamedTuple):
        >>>     fish: int = 5
        >>>     meat: int = 10
        >>>     drink: int = 7

        >>> today = create_dictlike_namedtuple(menu, fish=3, meat=13)
        >>> for key, value in today.items():
        >>>     print(key, value)
            fish 3
            meat 13
            drink 7

        >>> print(today)
            BaseNamedTuple('menu', {'fish': 3, 'meat': 13, 'drink': 7})

        >>> print(today["meat"], today.fish)
            13 3

        >>> today["fish"] = 10
            TypeError: 'WrapedNamedTuple' object does not support item assignment

    """
    TargetNamedTuple: Any = target_namedtuple

    class WrapedNamedTuple(TargetNamedTuple, BaseNamedTuple):
        def __getitem__(self, key: Union[str, int]) -> Any:
            if type(key) is int:
                # The exceptional process for python 3.7
                return self._asdict()[self._fields[key]]

            str_key: str = str(key)
            if hasattr(self, str_key):
                return getattr(self, str_key)
            else:
                raise AttributeError(f"NamedTuple does not have the attribute name {key}")

        def __repr__(self) -> str:
            tuple_name = self.__class__.__bases__[0].__name__
            header = f"BaseNamedTuple('{tuple_name}', "
            ret = "{"
            for key, value in self._asdict().items():
                ret += f"'{key}': {value}, "

            ret = ret[:-2] + "})" if len(ret) > 1 else ret + "})"
            return "".join([header, ret])

    if not hasattr(TargetNamedTuple, "__annotations__"):
        raise KeyError("BaseNamedTuple must have at least one variable.")

    _prohibited_name_usages = list(set(_prohibited) & set(TargetNamedTuple.__annotations__.keys()))

    if len(_prohibited_name_usages):
        raise AttributeError(f"Cannot overwrite BaseNamedTuple attribute '{_prohibited_name_usages}'. "
                             "Use another variable name.")

    return WrapedNamedTuple(**kwargs)


class FitRequirement(NamedTuple):
    """
    A class that holds inputs required to fit a pipeline. Also indicates wether
    requirements have to be user specified or are generated by the pipeline itself.

    Attributes:
    name: The name of the variable expected in the input dictionary
    supported_types: An iterable of all types that are supported
    user_defined: If false, this requirement does not have to be given to the pipeline
    """

    name: str
    supported_types: Iterable[Type]
    user_defined: bool
    dataset_property: bool

    def __str__(self) -> str:
        """
        String representation for the requirements
        """
        return "Name: %s | Supported types: %s | User defined: %s | Dataset property: %s" % (
            self.name, self.supported_types, self.user_defined, self.dataset_property)


def replace_prefix_in_config_dict(config: Dict[str, Any], prefix: str, replace: str = "") -> Dict[str, Any]:
    """
    Replace the prefix in all keys with the specified replacement string (the empty string by
    default to remove the prefix from the key). The functions makes sure that the prefix is a proper config
    prefix by checking if it ends with ":", if not it appends ":" to the prefix.

    :param config: config dictionary where the prefixed of the keys should be replaced
    :param prefix: prefix to be replaced in each key
    :param replace: the string to replace the prefix with
    :return: updated config dictionary
    """
    # make sure that prefix ends with the config separator ":"
    if not prefix.endswith(":"):
        prefix = prefix + ":"
    # only replace first occurrence of the prefix
    return {k.replace(prefix, replace, 1): v
            for k, v in config.items() if
            k.startswith(prefix)}


def custom_collate_fn(batch: List) -> List[Optional[torch.tensor]]:
    """
    In the case of not providing a y tensor, in a
    dataset of form {X, y}, y would be None.

    This custom collate function allows to yield
    None data for functions that require only features,
    like predict.

    Args:
        batch (List): a batch from a dataset

    Returns:
        List[Optional[torch.Tensor]]
    """

    items = list(zip(*batch))

    # The feature will always be available
    items[0] = default_collate(items[0])
    if None in items[1]:
        items[1] = list(items[1])
    else:
        items[1] = default_collate(items[1])
    return items


def replace_string_bool_to_bool(dictionary: Dict[str, Any]) -> Dict[str, Any]:
    """
    Utility function to replace string-type bool to
    bool when a dict is read from json

    Args:
        dictionary (Dict[str, Any])
    Returns:
        Dict[str, Any]
    """
    for key, item in dictionary.items():
        if isinstance(item, str):
            if item.lower() == "true":
                dictionary[key] = True
            elif item.lower() == "false":
                dictionary[key] = False
    return dictionary


def hash_array_or_matrix(X: Union[np.ndarray, pd.DataFrame]) -> str:
    """
    Creates a hash for a given array.
    Used for dataset name in case none is specified
    Args:
        X: (Union[np.ndarray, pd.DataFrame])
            data

    Returns:
        (str): hash of the data as string
    """
    m = hashlib.md5()

    if hasattr(X, "iloc"):
        X = X.to_numpy()

    if scipy.sparse.issparse(X):
        m.update(X.indices)
        m.update(X.indptr)
        m.update(X.data)
        m.update(str(X.shape).encode('utf8'))
    else:
        if X.flags['C_CONTIGUOUS']:
            m.update(X.data)
            m.update(str(X.shape).encode('utf8'))
        else:
            X_tmp = np.ascontiguousarray(X.T)
            m.update(X_tmp.data)
            m.update(str(X_tmp.shape).encode('utf8'))

    hash = m.hexdigest()
    return hash


def get_device_from_fit_dictionary(X: Dict[str, Any]) -> torch.device:
    """
    Get a torch device object by checking if the fit dictionary specifies a device. If not, or if no GPU is available
    return a CPU device.

    Args:
        X (Dict[str, Any]): A fit dictionary to control how the pipeline is fitted

    Returns:
        torch.device: Device to be used for training/inference
    """
    if not torch.cuda.is_available():
        return torch.device("cpu")

    return torch.device(X.get("device", "cpu"))


def subsampler(data: Union[np.ndarray, pd.DataFrame, scipy.sparse.csr_matrix],
               x: Union[np.ndarray, List[int]]
               ) -> Union[np.ndarray, pd.DataFrame, scipy.sparse.csr_matrix]:
    return data[x] if isinstance(data, (np.ndarray, scipy.sparse.csr_matrix)) else data.iloc[x]
